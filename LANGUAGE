Goal: transparency, simplicity

The user should know exactly what is going on at all times.

1 instruction:
write value at some location.
if something, go here, else go there.

functions: labels for line numbers.

function is just namespace. variables are named with slashes
like dictionaries.

write 0 to 100000.
if 100000 equals 1, go to 1000, else go to 500.

write 0-128 to bob

libraries define: functions, structs.
only one executable named main()

sample:

int handle_signal(int32 count, 
    SYSTEM_IDLE = 0
    PC 


Example 1: Fibonacci sequence
# if no arguments, just parenthesis
(int current) fibonacci(int index)
    last = 1
    current = 1
    while (index != 0):
        current += last
        index -=1

counter = 5
value = fibonacci(counter)

Example 2: 
a = (b + (c + d))
a = (b + (c + d * (hello)))
# if, else
if a == 5:
    b = 5
    return
elif b == 6:

operation:
a + 5

== Compiler ==
Compiler's job is to read program text and spit out executable.

assume stack begins at top.
int is 16 bits. starting from top - 16, write 5


